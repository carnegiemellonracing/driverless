{"version":3,"file":"lib_index_js.e1684daab4071df2a519.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAuD;AACN;AACO;AACA;AACT;AACgB;AACf;AAChD;AAC4B;AAC5B;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,oCAAoC;AACpC,8BAA8B;AAC9B,wDAAwD;AACxD,sDAAsD;AACtD,kCAAkC;AAClC,iCAAiC;AACjC,2CAA2C;AAC3C,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,GAAG;AAC9B,8BAA8B,GAAG;AACjC;AACA;AACA;AACA,6BAA6B;AAC7B,8BAA8B;AAC9B,kDAAkD;AAClD;AACA,yBAAyB;AACzB,6BAA6B;AAC7B,wBAAwB;AACxB,wBAAwB;AACxB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA,SAAS;AACT,oCAAoC,2BAA2B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,aAAa;AACtD,wBAAwB,0DAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,qCAAqC,qCAAqC,MAAM;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA,4CAA4C,qBAAqB;AACjE,aAAa;AACb;AACA;AACA;AACA;AACA,6CAA6C,qBAAqB;AAClE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA,wDAAwD;AACxD;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,KAAK;AACjC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B,KAAK;AACjC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,yCAAyC,8BAA8B;AACvE;AACA;AACA;AACA,4BAA4B,QAAQ,aAAa,eAAe,gBAAgB,QAAQ,8CAA8C,cAAc,mDAAmD;AACvM;AACA;AACA;AACA,6BAA6B,QAAQ,aAAa,eAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA,uBAAuB;AACvB,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sBAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wBAAwB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,uBAAuB;AACvB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4BAA4B,SAAS,MAAM;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA,iIAAiI,QAAQ;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG,aAAa;AAClH,yEAAyE,QAAQ;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,QAAQ;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,IAAI;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kCAAkC;AACrE;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAgB;AACxB,QAAQ,kEAAc;AACtB,QAAQ,iEAAe;AACvB,QAAQ,2DAAS;AACjB,QAAQ,yDAAQ;AAChB,QAAQ,yEAAgB;AACxB;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;;;;AC70BtB;AACsH;AAC7B;AACzF,8BAA8B,mFAA2B,CAAC,wGAAqC;AAC/F;AACA,gFAAgF,kBAAkB,GAAG,gDAAgD,mBAAmB,GAAG,4BAA4B,mBAAmB,GAAG,8CAA8C,oBAAoB,kBAAkB,4BAA4B,uBAAuB,GAAG,4CAA4C,wCAAwC,uBAAuB,iBAAiB,eAAe,qBAAqB,uBAAuB,WAAW,uBAAuB,wBAAwB,eAAe,GAAG,8FAA8F,wBAAwB,GAAG,SAAS,iFAAiF,UAAU,MAAM,KAAK,UAAU,OAAO,KAAK,UAAU,OAAO,KAAK,UAAU,UAAU,YAAY,aAAa,OAAO,KAAK,YAAY,aAAa,WAAW,UAAU,YAAY,aAAa,WAAW,YAAY,aAAa,WAAW,MAAM,MAAM,YAAY,gEAAgE,kBAAkB,GAAG,gDAAgD,mBAAmB,GAAG,4BAA4B,mBAAmB,GAAG,8CAA8C,oBAAoB,kBAAkB,4BAA4B,uBAAuB,GAAG,4CAA4C,wCAAwC,uBAAuB,iBAAiB,eAAe,qBAAqB,uBAAuB,WAAW,uBAAuB,wBAAwB,eAAe,GAAG,8FAA8F,wBAAwB,GAAG,qBAAqB;AAC7yD;AACA,iEAAe,uBAAuB,EAAC;;;;;;;;;;;;;;;;;;;;ACPvC;AACsH;AAC7B;AACW;AACpG,8BAA8B,mFAA2B,CAAC,wGAAqC;AAC/F,0BAA0B,qFAAiC;AAC3D;AACA,mDAAmD,kEAAkE;AACrH;AACA,iEAAe,uBAAuB,EAAC;;;;;;;;;;;;;;;;;;ACTkD;AACzF,YAAuF;;AAEvF;;AAEA;AACA;;AAEA,aAAa,0GAAG,CAAC,sFAAO;;;;AAIxB,iEAAe,6FAAc,MAAM","sources":["webpack://jupyterlab-flake8/./lib/index.js","webpack://jupyterlab-flake8/./style/base.css","webpack://jupyterlab-flake8/./style/index.css","webpack://jupyterlab-flake8/./style/index.css?b7f0"],"sourcesContent":["import { ICommandPalette } from '@jupyterlab/apputils';\nimport { IMainMenu } from '@jupyterlab/mainmenu';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { IEditorTracker } from '@jupyterlab/fileeditor';\nimport { IStateDB } from '@jupyterlab/statedb';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { Terminal } from '@jupyterlab/terminal';\n// CSS\nimport '../style/index.css';\n// extension id\nconst id = 'jupyterlab-flake8';\nclass Preferences {\n    constructor() {\n        this.toggled = true; // turn on/off linter\n        this.lint_on_change = true; // lint on notebook/editor change\n        this.logging = false; // turn on/off logging\n        this.highlight_color = 'var(--jp-warn-color3)'; // color of highlights\n        this.gutter_color = 'var(--jp-error-color0)'; // color of gutter icons\n        this.term_timeout = 5000; // seconds before the temrinal times out if it has not received a message\n        this.conda_env = 'base'; // conda environment\n        this.terminal_name = 'flake8term'; // persistent terminal to share between session\n        this.configuration_file = ''; // global flake8 configuration file\n    }\n}\n/**\n * Linter\n */\nclass Linter {\n    constructor(app, notebookTracker, editorTracker, palette, mainMenu, state, settingRegistry) {\n        this.prefsKey = `${id}:preferences`;\n        this.settingsKey = `${id}:plugin`;\n        // Default Options\n        this.prefs = new Preferences();\n        // flags\n        this.loaded = false; // flag if flake8 is available\n        this.linting = false; // flag if the linter is processing\n        this.gutter_id = 'CodeMirror-lintgutter'; // gutter element id\n        // cache\n        this.marks = []; // text marker objects currently active\n        this.bookmarks = []; // text marker objects in editor // --- Temporary fix since gutter doesn't work in editor\n        this.docs = []; // text marker objects currently active\n        this.text = ''; // current nb text\n        this.os = ''; // operating system\n        this.app = app;\n        this.mainMenu = mainMenu;\n        this.notebookTracker = notebookTracker;\n        this.editorTracker = editorTracker;\n        this.palette = palette;\n        this.state = state;\n        this.settingRegistry = settingRegistry;\n        // load settings from the registry\n        Promise.all([\n            this.settingRegistry.load(this.settingsKey),\n            app.restored\n        ]).then(([settings]) => {\n            this.update_settings(settings, true);\n            // callback to update settings on changes\n            settings.changed.connect((settings) => {\n                this.update_settings(settings);\n            });\n            // on first load, if linter enabled, start it up\n            if (this.prefs.toggled) {\n                this.load_linter();\n            }\n        });\n        // activate function when cell changes\n        this.notebookTracker.currentChanged.connect(this.onActiveNotebookChanged, this);\n        // activate when editor changes\n        this.editorTracker.currentChanged.connect(this.onActiveEditorChanged, this);\n        // add menu item\n        this.add_commands();\n    }\n    /**\n     * Update settings callback\n     * @param {ISettingRegistry.ISettings} settings\n     */\n    update_settings(settings, first_load = false) {\n        const old = JSON.parse(JSON.stringify(this.prefs)); // copy old prefs\n        // set settings to prefs object\n        Object.keys(settings.composite).forEach((key) => {\n            this.prefs[key] = settings.composite[key];\n        });\n        this.log(`loaded settings ${JSON.stringify(this.prefs)}`);\n        // toggle linter\n        if (!first_load && old.toggled !== this.prefs.toggled) {\n            this.toggle_linter();\n        }\n    }\n    /**\n     * Load terminal session and flake8\n     */\n    async load_linter() {\n        // Bail if there are no terminals available.\n        if (!this.app.serviceManager.terminals.isAvailable()) {\n            this.log('Disabling jupyterlab-flake8 plugin because it cant access terminal');\n            this.loaded = false;\n            this.prefs.toggled = false;\n            return;\n        }\n        // try to connect to previous terminal, if not start a new one\n        // TODO: still can't set the name of a terminal, so for now saving the \"new\"\n        // terminal name in the settings (#16)\n        let session;\n        try {\n            session = await this.app.serviceManager.terminals.connectTo({\n                model: { name: this.prefs.terminal_name }\n            });\n        }\n        catch (e) {\n            this.log('starting new terminal session');\n            session = await this.app.serviceManager.terminals.startNew();\n        }\n        // save terminal name\n        this.setPreference('terminal_name', session.name);\n        // start a new terminal session\n        this.log(`set terminal_name to ${session.name}`);\n        this.term = new Terminal(session);\n        // flush on load\n        function _flush_on_load(sender, msg) {\n            return;\n        }\n        // this gets rid of any messages that might get sent on load\n        // may fix #28 or #31\n        this.term.session.messageReceived.connect(_flush_on_load, this);\n        // get OS\n        const _get_OS = (sender, msg) => {\n            if (msg.content) {\n                const message = msg.content[0];\n                // throw away non-strings\n                if (typeof message !== 'string') {\n                    return;\n                }\n                if (message.indexOf('command not found') > -1) {\n                    this.log('python command failed on this machine');\n                    this.term.session.messageReceived.disconnect(_get_OS, this);\n                    this.finish_load();\n                }\n                // set OS\n                if (message.indexOf('posix') > -1) {\n                    this.os = 'posix';\n                }\n                else if (message.indexOf('nt(') === -1 &&\n                    message.indexOf('int') === -1 &&\n                    message.indexOf('nt') > -1) {\n                    this.os = 'nt';\n                }\n                else {\n                    return;\n                }\n                this.log(`os: ${this.os}`);\n                // disconnect the os listener and connect empty listener\n                this.term.session.messageReceived.disconnect(_get_OS, this);\n                // setup stage\n                this.setup_terminal();\n            }\n        };\n        // wait a moment for terminal to load and then ask for OS\n        setTimeout(() => {\n            // disconnect flush\n            this.term.session.messageReceived.disconnect(_flush_on_load, this);\n            // ask for the OS\n            this.term.session.messageReceived.connect(_get_OS, this);\n            this.term.session.send({\n                type: 'stdin',\n                content: ['python -c \"import os; print(os.name)\"\\r']\n            });\n        }, 1500);\n    }\n    setup_terminal() {\n        if (this.os === 'posix') {\n            this.term.session.send({ type: 'stdin', content: ['HISTFILE= ;\\r'] });\n        }\n        // custom conda-env\n        if (this.prefs.conda_env !== 'base') {\n            this.set_env();\n        }\n        else {\n            this.finish_load();\n        }\n    }\n    // activate specific conda environment\n    set_env() {\n        this.log(`conda env: ${this.prefs.conda_env}`);\n        if (this.os === 'posix') {\n            this.term.session.send({\n                type: 'stdin',\n                content: [`conda activate ${this.prefs.conda_env}\\r`]\n            });\n        }\n        else if (this.os !== 'posix') {\n            this.term.session.send({\n                type: 'stdin',\n                content: [`source activate ${this.prefs.conda_env}\\r`]\n            });\n        }\n        this.finish_load();\n    }\n    finish_load() {\n        try {\n            // wait a moment for terminal to get initial commands out of its system\n            setTimeout(() => {\n                this.loaded = true;\n                this.activate_flake8();\n            }, 500);\n        }\n        catch (e) {\n            this.loaded = false;\n            this.prefs.toggled = false;\n            this.term.dispose();\n        }\n    }\n    /**\n     * Activate flake8 terminal reader\n     */\n    activate_flake8() {\n        // listen for stdout in onLintMessage\n        this.term.session.messageReceived.connect(this.onLintMessage, this);\n    }\n    /**\n     * Dispose of the terminal used to lint\n     */\n    dispose_linter() {\n        this.log('disposing flake8 and terminal');\n        this.lint_cleanup();\n        this.clear_marks();\n        if (this.term) {\n            this.term.session.messageReceived.disconnect(this.onLintMessage, this);\n            this.term.dispose();\n        }\n    }\n    /**\n     * load linter when notebook changes\n     */\n    onActiveNotebookChanged() {\n        // return if file is being closed\n        if (!this.notebookTracker.currentWidget) {\n            return;\n        }\n        // select the notebook\n        this.notebook = this.notebookTracker.currentWidget.content;\n        this.checkNotebookGutters();\n        // run on cell changing\n        this.notebookTracker.activeCellChanged.disconnect(this.onActiveCellChanged, this);\n        this.notebookTracker.activeCellChanged.connect(this.onActiveCellChanged, this);\n        // run on stateChanged\n        this.notebook.model.stateChanged.disconnect(this.onActiveCellChanged, this);\n        this.notebook.model.stateChanged.connect(this.onActiveCellChanged, this);\n    }\n    /**\n     * Run linter when active cell changes\n     */\n    onActiveCellChanged() {\n        this.checkNotebookGutters();\n        // note this check must be here, not in the parent onActive function\n        if (this.loaded && this.prefs.toggled && this.prefs.lint_on_change) {\n            if (!this.linting) {\n                this.lint_notebook();\n            }\n            else {\n                this.log('flake8 is already running onActiveCellChanged');\n            }\n        }\n    }\n    /**\n     * load linter when active editor loads\n     */\n    onActiveEditorChanged() {\n        // return if file is being closed\n        if (!this.editorTracker.currentWidget) {\n            return;\n        }\n        // select the editor\n        this.editor = this.editorTracker.currentWidget.content;\n        this.checkEditorGutters();\n        // run on stateChanged\n        this.editor.model.stateChanged.disconnect(this.onActiveEditorChanges, this);\n        this.editor.model.stateChanged.connect(this.onActiveEditorChanges, this);\n    }\n    /**\n     * Run linter on active editor changes\n     */\n    onActiveEditorChanges() {\n        this.checkEditorGutters();\n        // note this check must be here, not in the parent onActive function\n        if (this.loaded && this.prefs.toggled && this.prefs.lint_on_change) {\n            if (!this.linting) {\n                this.lint_editor();\n            }\n            else {\n                this.log('flake8 is already running onEditorChanged');\n            }\n        }\n    }\n    checkNotebookGutters() {\n        this.notebook.widgets.forEach((widget) => {\n            const editor = widget.inputArea.editor;\n            const lineNumbers = editor._config.lineNumbers;\n            const codeFolding = editor._config.codeFolding;\n            const gutters = [\n                lineNumbers && 'CodeMirror-linenumbers',\n                codeFolding && 'CodeMirror-foldgutter',\n                this.gutter_id\n            ].filter(d => d);\n            editor.editor.setOption('gutters', gutters);\n        });\n    }\n    checkEditorGutters() {\n        // let editor = this.editorTracker.currentWidget.content;\n        // let editorWidget = this.editorTracker.currentWidget;\n        const editor = this.editor.editor;\n        const lineNumbers = editor._config.lineNumbers;\n        const codeFolding = editor._config.codeFolding;\n        const gutters = [\n            lineNumbers && 'CodeMirror-linenumbers',\n            codeFolding && 'CodeMirror-foldgutter',\n            this.gutter_id\n        ].filter(d => d);\n        editor.setOption('gutters', gutters);\n    }\n    /**\n     * Generate lint command\n     *\n     * @param  {string} contents - contents of the notebook ready to be linted\n     * @return {string} [description]\n     */\n    lint_cmd(contents) {\n        // escaped characters common to powershell and unix\n        let escaped = contents.replace(/[`\\\\]/g, '\\\\$&');\n        // escaped characters speciic to shell\n        if (this.os === 'nt') {\n            escaped = contents.replace(/[\"]/g, '`$&'); // powershell\n        }\n        else {\n            escaped = contents.replace(/[\"]/g, '\\\\$&'); // unix\n        }\n        escaped = escaped.replace('\\r', ''); // replace carriage returns\n        // ignore magics by commenting\n        escaped = escaped\n            .split('\\n')\n            // handle ipy magics %% and %\n            .map((line) => {\n            if (line.startsWith('%%')) {\n                return `# ${line}`;\n            }\n            else {\n                return line;\n            }\n        })\n            .map((line) => {\n            if (line.startsWith('%')) {\n                return `# ${line}`;\n            }\n            else {\n                return line;\n            }\n        })\n            .join(this.newline());\n        // remove final \\n (#20)\n        if (escaped.endsWith(this.newline())) {\n            if (this.os === 'nt') {\n                escaped = escaped.slice(0, -2); // powershell\n            }\n            else {\n                escaped = escaped.slice(0, -1); // unix\n            }\n        }\n        let config_option = '';\n        if (this.prefs.configuration_file !== null &&\n            this.prefs.configuration_file !== '') {\n            config_option = `--config=\"${this.prefs.configuration_file}\"`;\n        }\n        if (this.os === 'nt') {\n            // powershell\n            return `echo \"${escaped}\" | flake8 ${config_option} --exit-zero - ; if($?) {echo \"@jupyterlab-flake8 finished linting\"} ; if (-not $?) {echo \"@jupyterlab-flake8 finished linting failed\"} `;\n        }\n        else {\n            // unix\n            return `(echo \"${escaped}\" | flake8 ${config_option} --exit-zero - && echo \"@jupyterlab-flake8 finished linting\" ) || (echo \"@jupyterlab-flake8 finished linting failed\")`;\n        }\n    }\n    /**\n     * Determine new line character based on platform\n     */\n    newline() {\n        // powershell by default on windows\n        if (this.os === 'nt') {\n            return '`n';\n            // otherwise unix\n        }\n        else {\n            return '\\n';\n        }\n    }\n    /**\n     * Determine if text is input\n     * @param {string} text [description]\n     */\n    text_exists(text) {\n        return text;\n        // return text && text !== '\\n' && text !== '\\n\\n';\n    }\n    /**\n     * Clear all current marks from code mirror\n     */\n    clear_marks() {\n        // clear marks\n        this.marks.forEach((mark) => {\n            mark.clear();\n        });\n        this.marks = [];\n        // --- Temporary fix since gutter doesn't work in editor\n        // clear error messages in editor\n        this.clear_error_messages();\n        // clear gutter\n        this.docs.forEach((doc) => {\n            doc.cm.clearGutter(this.gutter_id);\n        });\n        this.docs = [];\n    }\n    /**\n     * Lint the CodeMirror Editor\n     */\n    lint_editor() {\n        this.linting = true; // no way to turn this off yet\n        this.process_mark = this.mark_editor;\n        // catch if file is not a .py file\n        if (this.editor.context.path.indexOf('.py') > -1 ||\n            this.editor.model._defaultLang === 'python') {\n            this.log('getting editor text from python file');\n        }\n        else {\n            this.log('not python default lang');\n            this.lint_cleanup();\n            return;\n        }\n        const pytext = this.editor.model.value.text;\n        this.lint(pytext);\n    }\n    /**\n     * mark the editor pane\n     * @param {number} line    [description]\n     * @param {number} ch      [description]\n     */\n    mark_editor(line, ch) {\n        this.log('marking editor');\n        line = line - 1; // 0 index\n        ch = ch - 1; // not sure\n        // get lines\n        const from = { line: line, ch: ch };\n        const to = { line: line, ch: ch + 1 };\n        // get code mirror editor\n        const doc = this.editor.editorWidget.editor.doc;\n        return { context: 'editor', doc, from, to };\n    }\n    /**\n     * Run flake8 linting on notebook cells\n     */\n    lint_notebook() {\n        this.linting = true; // no way to turn this off yet\n        this.process_mark = this.mark_notebook;\n        // load notebook\n        this.cells = this.notebook.widgets;\n        this.log('getting notebook text');\n        // return text from each cell if its a code cell\n        this.cell_text = this.cells.map((cell, cell_idx, cell_arr) => {\n            if (cell.model.type === 'code' &&\n                this.text_exists(cell.model.value.text)) {\n                // append \\n\\n if its not the last cell\n                if (cell_idx !== cell_arr.length - 1) {\n                    return `${cell.model.value.text}\\n\\n`;\n                }\n                else {\n                    return cell.model.value.text;\n                }\n            }\n            else {\n                return '';\n            }\n        });\n        // create dictionary of lines\n        this.lookup = {};\n        let line = 1;\n        this.cell_text.map((cell, cell_idx, cell_arr) => {\n            // if there is text in the cell,\n            if (this.text_exists(cell)) {\n                const lines = cell.split('\\n');\n                for (let idx = 0; idx < lines.length - 1; idx++) {\n                    this.lookup[line] = {\n                        cell: cell_idx,\n                        line: idx\n                    };\n                    line += 1;\n                }\n            }\n            // if its the last cell in the notebook and its empty\n            else if (cell_idx === cell_arr.length - 1) {\n                this.lookup[line] = {\n                    cell: cell_idx,\n                    line: 0\n                };\n            }\n        });\n        // ignore other languages (#32)\n        // this seems to be all %%magic commands except %%capture\n        this.cell_text = this.cell_text.map((cell, cell_idx, cell_arr) => {\n            const firstline = cell.split('\\n')[0];\n            if (firstline &&\n                firstline.startsWith('%%') &&\n                !(firstline.indexOf('%%capture') > -1)) {\n                return cell\n                    .split('\\n')\n                    .map((t) => (t !== '' ? `# ${t}` : ''))\n                    .join('\\n');\n            }\n            else {\n                return cell;\n            }\n        });\n        // join cells with text with two new lines\n        const pytext = this.cell_text.join('');\n        // run linter\n        this.lint(pytext);\n    }\n    /**\n     * mark the line of the cell\n     * @param {number} line    the line # returned by flake8\n     * @param {number} ch      the character # returned by flake 8\n     */\n    mark_notebook(line, ch) {\n        const loc = this.lookup[line];\n        ch = ch - 1; // make character 0 indexed\n        if (!loc) {\n            return;\n        }\n        const from = { line: loc.line, ch: ch };\n        const to = { line: loc.line, ch: ch + 1 };\n        // get cell instance\n        const cell = this.notebook.widgets[loc.cell];\n        // get cell's code mirror editor\n        const editor = cell.inputArea.editorWidget\n            .editor;\n        const doc = editor.doc;\n        return { context: 'notebook', doc, from, to };\n    }\n    /**\n     * Lint a python text message and callback marking function with line and character\n     * @param {string}   pytext        [description]\n     */\n    lint(pytext) {\n        // cache pytext on text\n        if (pytext !== this.text) {\n            this.text = pytext;\n        }\n        else {\n            // text has not changed\n            this.log('text unchanged');\n            this.lint_cleanup();\n            return;\n        }\n        // TODO: handle if text is empty (any combination of '' and \\n)\n        if (!this.text_exists(this.text)) {\n            this.log('text empty');\n            this.lint_cleanup();\n            return;\n        }\n        // clean current marks\n        this.clear_marks();\n        // get lint command to run in terminal and send to terminal\n        this.log('preparing lint command');\n        const lint_cmd = this.lint_cmd(pytext);\n        this.log('sending lint command');\n        this.term.session.send({ type: 'stdin', content: [`${lint_cmd}\\r`] });\n        this.termTimeoutHandle = setTimeout(() => {\n            if (this.linting) {\n                this.log('lint command timed out');\n                alert('jupyterlab-flake8 ran into an issue connecting with the terminal. Please try reloading the browser or re-installing the jupyterlab-flake8 extension.');\n                this.lint_cleanup();\n                this.dispose_linter();\n                this.prefs.toggled = false;\n            }\n        }, this.prefs.term_timeout);\n    }\n    /**\n     * Handle terminal message during linting\n     * TODO: import ISession and IMessage types for sender and msg\n     * @param {any} sender [description]\n     * @param {any} msg    [description]\n     */\n    onLintMessage(sender, msg) {\n        clearTimeout(this.termTimeoutHandle);\n        if (msg.content) {\n            const message = msg.content[0];\n            // catch non-strings\n            if (typeof message !== 'string') {\n                return;\n            }\n            // log message\n            this.log(`terminal message: ${message}`);\n            // if message a is a reflection of the command, return\n            if (message.indexOf('Traceback') > -1) {\n                alert(`Flake8 encountered a python error. Make sure flake8 is installed and on the system path. \\n\\nTraceback: ${message}`);\n                this.lint_cleanup();\n                return;\n            }\n            // if message a is a reflection of the command, return\n            if (message.indexOf('command not found') > -1) {\n                alert(\"Flake8 was not found in this python environment. \\n\\nIf you are using a conda environment, set the 'conda_env' setting in the Advanced Settings menu and reload the Jupyter Lab window.\\n\\nIf you are not using a conda environment, Install Flake8 with 'pip install flake8' or 'conda install flake8' and reload the Jupyter Lab window\");\n                this.lint_cleanup();\n                return;\n            }\n            message.split(/(?:\\n|\\[)/).forEach(m => {\n                if (m.includes('stdin:')) {\n                    const idxs = m.split(':');\n                    const line = parseInt(idxs[1]);\n                    const ch = parseInt(idxs[2]);\n                    this.log(idxs[3]);\n                    this.get_mark(line, ch, idxs[3].slice(0, -1));\n                }\n            });\n            if (message.indexOf('jupyterlab-flake8 finished linting') > -1) {\n                this.lint_cleanup();\n            }\n        }\n    }\n    /**\n     * Mark a line in notebook or editor\n     * @param {number} line    [description]\n     * @param {number} ch      [description]\n     * @param {string} message [description]\n     */\n    get_mark(line, ch, message) {\n        try {\n            if (this.process_mark && typeof this.process_mark === 'function') {\n                const { doc, from, to, context } = this.process_mark(line, ch);\n                if (!doc || !from || !to) {\n                    this.log('mark location not fully defined');\n                    return;\n                }\n                this.mark_line(doc, from, to, message, context);\n            }\n        }\n        catch (e) {\n            this.log('failed to run process_mark');\n            return;\n        }\n    }\n    /**\n     * Mark line in document\n     * @param {any}    doc     [description]\n     * @param {any}    from    [description]\n     * @param {any}    to      [description]\n     * @param {string} message [description]\n     */\n    mark_line(doc, from, to, message, context) {\n        const gutter_color = this.prefs.gutter_color;\n        // gutter marker - this doesn't work in the editor\n        function makeMarker() {\n            const marker = document.createElement('div');\n            marker.innerHTML = `<div class='jupyterlab-flake8-lint-gutter-container' style='color: ${gutter_color}''>\n        <div>â—‰</div><div class='jupyterlab-flake8-lint-gutter-message'>${message}</div>\n      </div>`;\n            return marker;\n        }\n        // store gutter marks for later\n        doc.cm.setGutterMarker(from.line, this.gutter_id, makeMarker());\n        this.docs.push(doc);\n        // --- Temporary fix since gutters don't show up in editor\n        // show error message in editor\n        if (context === 'editor') {\n            const lint_alert = document.createElement('span');\n            const lint_message = document.createTextNode(`------ ${message}`);\n            lint_alert.appendChild(lint_message);\n            lint_alert.className = 'jupyterlab-flake8-lint-message-inline';\n            // add error alert node to the 'to' location\n            this.bookmarks.push(doc.addLineWidget(from.line, lint_alert));\n        }\n        // mark the text position with highlight\n        this.marks.push(doc.markText(from, to, {\n            // replacedWith: selected_char_node,\n            className: 'jupyterlab-flake8-lint-message',\n            css: `\n          background-color: ${this.prefs.highlight_color}\n        `\n        }));\n    }\n    /**\n     * // --- Temporary fix since gutters don't show up in editor\n     * Clear all error messages\n     */\n    clear_error_messages() {\n        this.bookmarks.forEach((bookmark) => {\n            bookmark.clear();\n        });\n    }\n    /**\n     * Tear down lint fixtures\n     */\n    lint_cleanup() {\n        this.linting = false;\n        // this.process_mark = undefined;\n    }\n    /**\n     * Show browser logs\n     * @param {any} msg [description]\n     */\n    log(msg) {\n        // return if prefs.logging is not enabled\n        if (!this.prefs.logging) {\n            return;\n        }\n        // convert object messages to strings\n        if (typeof msg === 'object') {\n            msg = JSON.stringify(msg);\n        }\n        // prepend name\n        const output = `jupyterlab-flake8: ${msg}`;\n        console.log(output);\n    }\n    /**\n     * Create menu / command items\n     */\n    add_commands() {\n        const category = 'Flake8';\n        // define all commands\n        const commands = {\n            'flake8:toggle': {\n                label: 'Enable Flake8',\n                isEnabled: () => {\n                    return this.loaded;\n                },\n                isToggled: () => {\n                    return this.prefs.toggled;\n                },\n                execute: async () => {\n                    this.setPreference('toggled', !this.prefs.toggled);\n                }\n            },\n            'flake8:lint_on_change': {\n                label: 'Run Flake8 on notebook/editor change',\n                isEnabled: () => {\n                    return this.loaded && this.prefs.toggled;\n                },\n                isToggled: () => {\n                    return this.prefs.lint_on_change;\n                },\n                execute: () => {\n                    this.setPreference('lint_on_change', !this.prefs.lint_on_change);\n                }\n            },\n            'flake8:run_lint_notebook': {\n                label: 'Lint active notebook',\n                isEnabled: () => {\n                    return this.loaded && this.prefs.toggled;\n                },\n                execute: () => {\n                    if (!(this.loaded && this.prefs.toggled)) {\n                        return;\n                    }\n                    // return if undefined\n                    if (!this.notebookTracker.currentWidget) {\n                        return;\n                    }\n                    // select the notebook\n                    this.notebook = this.notebookTracker.currentWidget.content;\n                    this.checkNotebookGutters();\n                    this.lint_notebook();\n                }\n            },\n            'flake8:run_lint_editor': {\n                label: 'Lint active editor',\n                isEnabled: () => {\n                    return this.loaded && this.prefs.toggled;\n                },\n                execute: () => {\n                    if (!(this.loaded && this.prefs.toggled)) {\n                        return;\n                    }\n                    // return if file is being closed\n                    if (!this.editorTracker.currentWidget) {\n                        return;\n                    }\n                    // select the editor\n                    this.editor = this.editorTracker.currentWidget.content;\n                    this.checkEditorGutters();\n                    this.lint_editor();\n                }\n            }\n        };\n        // add commands to menus and palette\n        for (const key in commands) {\n            this.app.commands.addCommand(key, commands[key]);\n            this.palette.addItem({ command: key, category: category });\n        }\n        // add to view Menu\n        this.mainMenu.viewMenu.addGroup(Object.keys(commands)\n            .filter(key => ['flake8:toggle', 'flake8:lint_on_change'].indexOf(key) > -1)\n            .map(key => {\n            return { command: key };\n        }), 30);\n    }\n    /**\n     * Turn linting on/off\n     */\n    toggle_linter() {\n        if (this.prefs.toggled) {\n            this.load_linter();\n        }\n        else {\n            this.dispose_linter();\n        }\n    }\n    /**\n     * Save state preferences\n     */\n    async setPreference(key, val) {\n        await Promise.all([\n            this.settingRegistry.load(this.settingsKey),\n            this.app.restored\n        ]).then(([settings]) => {\n            settings.set(key, val); // will automatically call update\n        });\n    }\n}\n/**\n * Activate extension\n */\nfunction activate(app, notebookTracker, editorTracker, palette, mainMenu, state, settingRegistry) {\n    new Linter(app, notebookTracker, editorTracker, palette, mainMenu, state, settingRegistry);\n}\n/**\n * Initialization data for the jupyterlab-flake8 extension.\n */\nconst plugin = {\n    id: 'jupyterlab-flake8',\n    autoStart: true,\n    activate: activate,\n    requires: [\n        INotebookTracker,\n        IEditorTracker,\n        ICommandPalette,\n        IMainMenu,\n        IStateDB,\n        ISettingRegistry\n    ]\n};\nexport default plugin;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".jupyterlab-flake8-lint-message span {\\n  display: none;\\n}\\n\\n.jupyterlab-flake8-lint-message span:hover {\\n  display: block;\\n}\\n\\n.CodeMirror-lintgutter {\\n  padding: 0 8px;\\n}\\n\\n.jupyterlab-flake8-lint-gutter-container {\\n  cursor: pointer;\\n  display: flex;\\n  justify-content: center;\\n  position: relative;\\n}\\n\\n.jupyterlab-flake8-lint-gutter-message {\\n  background: var(--jp-layout-color4);\\n  border-radius: 4px;\\n  color: white;\\n  left: 16px;\\n  padding: 2px 5px;\\n  position: absolute;\\n  top: 0;\\n  visibility: hidden;\\n  white-space: nowrap;\\n  z-index: 1;\\n}\\n\\n.jupyterlab-flake8-lint-gutter-container:hover\\n  .jupyterlab-flake8-lint-gutter-message {\\n  visibility: visible;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./style/base.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,aAAa;AACf;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,eAAe;EACf,aAAa;EACb,uBAAuB;EACvB,kBAAkB;AACpB;;AAEA;EACE,mCAAmC;EACnC,kBAAkB;EAClB,YAAY;EACZ,UAAU;EACV,gBAAgB;EAChB,kBAAkB;EAClB,MAAM;EACN,kBAAkB;EAClB,mBAAmB;EACnB,UAAU;AACZ;;AAEA;;EAEE,mBAAmB;AACrB\",\"sourcesContent\":[\".jupyterlab-flake8-lint-message span {\\n  display: none;\\n}\\n\\n.jupyterlab-flake8-lint-message span:hover {\\n  display: block;\\n}\\n\\n.CodeMirror-lintgutter {\\n  padding: 0 8px;\\n}\\n\\n.jupyterlab-flake8-lint-gutter-container {\\n  cursor: pointer;\\n  display: flex;\\n  justify-content: center;\\n  position: relative;\\n}\\n\\n.jupyterlab-flake8-lint-gutter-message {\\n  background: var(--jp-layout-color4);\\n  border-radius: 4px;\\n  color: white;\\n  left: 16px;\\n  padding: 2px 5px;\\n  position: absolute;\\n  top: 0;\\n  visibility: hidden;\\n  white-space: nowrap;\\n  z-index: 1;\\n}\\n\\n.jupyterlab-flake8-lint-gutter-container:hover\\n  .jupyterlab-flake8-lint-gutter-message {\\n  visibility: visible;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../node_modules/css-loader/dist/runtime/api.js\";\nimport ___CSS_LOADER_AT_RULE_IMPORT_0___ from \"-!../node_modules/css-loader/dist/cjs.js!./base.css\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n___CSS_LOADER_EXPORT___.i(___CSS_LOADER_AT_RULE_IMPORT_0___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\n\", \"\",{\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\",\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","import api from \"!../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../node_modules/css-loader/dist/cjs.js!./index.css\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};"],"names":[],"sourceRoot":""}