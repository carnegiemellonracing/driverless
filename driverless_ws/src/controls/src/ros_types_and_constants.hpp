#pragma once
#include <rclcpp/rclcpp.hpp>
// Note: these header files are part of the ROS2 standard libraries
#include <geometry_msgs/msg/twist_stamped.hpp>
#include <geometry_msgs/msg/quaternion_stamped.hpp>
#include <geometry_msgs/msg/pose_stamped.hpp>
// Note: these header files are generated by ROS2 from the .msg files in the interfaces package.
#include <interfaces/msg/spline_frames.hpp>
#include <interfaces/msg/control_action.hpp>
#include <interfaces/msg/controls_state.hpp>
#include <interfaces/msg/controller_info.hpp>
#include <geometry_msgs/msg/vector3_stamped.hpp>
#include <interfaces/msg/cone_array.hpp>

namespace controls {
    /// ROS Message Types
    ///@TODO: why not use std_msgs/Header for our custom messages?
    ///@TODO: related: builtin_interfaces/Time vs Time stamp - should standardize right?
    using TwistMsg = geometry_msgs::msg::TwistStamped; ///< 3D linear velocity, 3D angular velocity, timestamp
    using QuatMsg = geometry_msgs::msg::QuaternionStamped; ///< @TODO: don't see this anywhere, delete (encompassed by Pose)?
    using PoseMsg = geometry_msgs::msg::PoseStamped; ///< 3D position, 3D orientation, timestamp
    using SplineMsg = interfaces::msg::SplineFrames; ///< Array of 3D splint points, timestamp
    using ActionMsg = interfaces::msg::ControlAction; ///< 4 wheel torques, steering angle, timestamp
    using StateMsg = interfaces::msg::ControlsState; ///< p=4 dimensional state: x, y, yaw, speed. Derived from twist and pose.
    using InfoMsg = interfaces::msg::ControllerInfo; ///< State, control action, latency info
    using ConeMsg = interfaces::msg::ConeArray; /// Array of coloured cone positions
    using PIDMsg = geometry_msgs::msg::Point;
    using PositionLLAMsg = geometry_msgs::msg::Vector3Stamped;
    using IMUAccelerationMsg = geometry_msgs::msg::Vector3Stamped;

    /* ROS Topics */

    constexpr const char *controller_node_name = "controller";
    constexpr const char *control_action_topic_name = "control_action";
    constexpr const char *spline_topic_name = "spline";
    constexpr const char *state_topic_name = "state";
    constexpr const char *cone_topic_name = "perc_cones"; //Is this right? didn't exist before
    constexpr const char *world_twist_topic_name = "filter/twist";
    constexpr const char *world_quat_topic_name = "filter/quaternion";
    constexpr const char *world_pose_topic_name = "filter/pose";
    constexpr const char *controller_info_topic_name = "controller_info";
    constexpr const char *pid_topic_name = "pid_values";
    constexpr const char *world_position_lla_topic_name = "filter/positionlla";
    // for breezeway testing
    constexpr const char *imu_accel_topic_name = "imu/acceleration";
    constexpr const char *republished_perc_cones_topic_name = "perc_cones_republished";

    /// Profile for best effort communication
    static const rmw_qos_profile_t best_effort_profile = {
        RMW_QOS_POLICY_HISTORY_KEEP_LAST,
        1,
        RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT,
        RMW_QOS_POLICY_DURABILITY_VOLATILE,
        RMW_QOS_DEADLINE_DEFAULT,
        RMW_QOS_LIFESPAN_DEFAULT,
        RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT,
        RMW_QOS_LIVELINESS_LEASE_DURATION_DEFAULT,
        false
    };
    const rclcpp::QoS best_effort_qos = rclcpp::QoS(
        rclcpp::QoSInitialization(
          best_effort_profile.history,
          best_effort_profile.depth
        ),
        best_effort_profile);

    const rclcpp::QoS control_action_qos = best_effort_qos;
    const rclcpp::QoS spline_qos (rclcpp::KeepLast(1));
    const rclcpp::QoS state_qos (rclcpp::KeepLast(1));
    const rclcpp::QoS world_twist_qos (rclcpp::KeepLast(1));
    const rclcpp::QoS world_quat_qos (rclcpp::KeepLast(1)); 
    const rclcpp::QoS world_pose_qos (rclcpp::KeepLast(1));
    const rclcpp::QoS controller_info_qos = best_effort_qos;
    const rclcpp::QoS pid_qos (rclcpp::KeepLast(1));
    const rclcpp::QoS imu_accel_qos (rclcpp::KeepLast(1));
    const rclcpp::QoS world_position_lla_qos (rclcpp::KeepLast(1));
    const rclcpp::QoS republished_perc_cones_qos (rclcpp::KeepLast(1));

    const rmw_qos_profile_t keep_last_profile = spline_qos.get_rmw_qos_profile();

    
    constexpr rcl_clock_type_t default_clock_type = RCL_ROS_TIME;

}